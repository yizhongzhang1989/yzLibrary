/***********************************************************/
/**	\file
	\brief		Texture
	\author		Yizhong Zhang
	\date		6/24/2012
*/
/***********************************************************/
#ifndef __YZ_TEXTURE_H__
#define __YZ_TEXTURE_H__

#include "yzLib/yz_setting.h"

#if !(defined(YZ_glut_h) || defined(YZ_freeglut_h))
#	error yz_texture.h must be included after glut.h or freeglut.h
#endif


namespace yz{	namespace opengl{

/**
	class to hold opengl texture and related operations

	to use this class, following these guidelines:	\n
	1, call CreateTexture() at correct opengl context, i.e. right after window is created, or glutSetWindow() is called.	\n
	2, call SetupTexturePtr() to set texture dimension and load texture data, NULL is acceptable for just set size. \n
	3, call Bind() and UnBind() before and after using the texture in correct context. \n
	4, call LoadPtrToTexture() to update texture data (if pointer to data is set in SetupTexturePtr() did not change). \n
*/
class Texture{
public:
	GLuint	tex_id;					///<	texture id, generated by OpenGL

	int		tex_width, tex_height;	///<	texture dimension
	void*	tex_ptr;				///<	pointer to texture storage in memory
	GLint	tex_internal_format;	///<	internal texture format, typical GL_LUMINANCE, GL_RGB, GL_RGBA
	GLenum	tex_format;				///<	external texture format, typical GL_LUMINANCE, GL_RGB, GL_RGBA
	GLenum	mem_type;				///<	memory type, typical GL_FLOAT, GL_UNSIGNED_BYTE

	int		stride;					///<	stride, used for read data
	int		pack_size;				///<	pack size, used for alignment when loading texture

public:
	/**
		constructor, legal N is asserted
	*/
	Texture() {
		Reset();
	}
	~Texture(){}

	/**
		create OpenGL texture context

		\return		whether create texture succeed
	*/
	inline int CreateTexture(){
		if( status & TEXTURE_STATUS_BIT_CREATED ){
			#ifndef BE_QUIET
				std::cout << "texture already created, cannot create again" << std::endl;
			#endif
			return 0;
		}

		glGenTextures( 1, &tex_id );

		glBindTexture( GL_TEXTURE_2D, tex_id );
		glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
		glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
		#ifdef YZ_glew_h
			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		#endif
		glBindTexture( GL_TEXTURE_2D, 0 );

		status |= TEXTURE_STATUS_BIT_CREATED;
		return 1;
	}

	/**
		Setup texture pointer and type

		\param	width			texture width
		\param	height			texture height
		\param	stride_bytes	stride of this texture, in bytes
		\param	texture_ptr		memory storage of the texture, NULL is also acceptable
		\param	internal_format	internal format of the texture, GL_RGB, GL_RGBA, GL_LUMINANCE
		\param	format			format of the texture, GL_RGB, GL_RGBA, GL_LUMINANCE
		\param	memory_type		type of the memory, GL_UNSIGNED_BYTE, GL_FLOAT
		\return					whether create texture succeed
	*/
	inline int SetupTexturePtr(
		int		width,
		int		height,
		int		stride_bytes,
		void*	texture_ptr,
		GLint	internal_format = GL_RGB,
		GLenum	format = GL_RGB,
		GLenum	memory_type = GL_FLOAT
	) {
		if( !(status & TEXTURE_STATUS_BIT_CREATED) ){
			std::cout << "error: Texture::SetupTexturePtr, texture not created yet" << std::endl;
			return 0;
		}
		if( status & TEXTURE_STATUS_BIT_SETUP_PTR ){
			//	if the texture already setup, check whether we need to setup again
			if( tex_width == width && tex_height == height && 
				tex_internal_format == internal_format && tex_format == format && mem_type == memory_type ){
					//	existing texture is identical to the new, we do nothing but update the texture
					tex_ptr = texture_ptr;
					return LoadPtrToTexture();
			}
			//	else, the texture structure has changed, we need to create texture space again
		}
		GLint max_size;
		glGetIntegerv(GL_MAX_TEXTURE_SIZE, &max_size);
		if (tex_width > max_size || tex_height > max_size) {
			std::cout << "error: Texture::SetupTexturePtr, input texture size ("
				<< tex_width << 'x' << tex_height << ")too big, max size is: ("
				<< max_size << 'x' << max_size << ')' << std::endl;
			return 0;
		}

		tex_width	= width;
		tex_height	= height;
		tex_ptr		= texture_ptr;
		tex_internal_format	= internal_format;
		tex_format	= format;
		mem_type	= memory_type;
		stride		= stride_bytes;

		//	calculate pack size for alignment
		if( format == GL_RGBA || mem_type == GL_FLOAT )
			pack_size = 4;
		else if( format == GL_RGB )
			pack_size = (tex_width*3 % 4 ? ((tex_width*3 % 2 ? 1 : 2)) : 4);
		else{
			if( tex_width%4 == 0 )
				pack_size = 4;
			else if( tex_width%2 == 0 ){
				pack_size = 2;
			}
			else
				pack_size = 1;
		}

		status |= TEXTURE_STATUS_BIT_SETUP_PTR;

		if( pack_size != 4 ){
			glPushClientAttrib(GL_CLIENT_PIXEL_STORE_BIT);
			glPixelStorei(GL_UNPACK_ALIGNMENT, pack_size);
		}
		if (stride)
			glPixelStorei(GL_UNPACK_ROW_LENGTH, stride);

		//	create the texture
		Bind();
		glTexImage2D(GL_TEXTURE_2D, 0, tex_internal_format, tex_width, tex_height, 0, tex_format, mem_type, tex_ptr);
		UnBind();

		if( pack_size != 4 ){
			glPopClientAttrib();
		}
		glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);

		return 1;
	}

	/**
	Setup texture pointer and type (assume no stride)

	\param	width			texture width
	\param	height			texture height
	\param	texture_ptr		memory storage of the texture, NULL is also acceptable
	\param	internal_format	internal format of the texture, GL_RGB, GL_RGBA, GL_LUMINANCE
	\param	format			format of the texture, GL_RGB, GL_RGBA, GL_LUMINANCE
	\param	memory_type		type of the memory, GL_UNSIGNED_BYTE, GL_FLOAT
	\return					whether create texture succeed
	*/
	inline int SetupTexturePtr(
		int		width,
		int		height,
		void*	texture_ptr,
		GLint	internal_format = GL_RGB,
		GLenum	format = GL_RGB,
		GLenum	memory_type = GL_FLOAT
	) {
		return SetupTexturePtr(
			width,
			height,
			0,
			texture_ptr,
			internal_format,
			format,
			memory_type);
	}

	/**
		Load image stored in ptr space to texture
	*/
	inline int LoadPtrToTexture(){
		if( !(status & TEXTURE_STATUS_BIT_SETUP_PTR) ){
			#ifndef BE_QUIET
				std::cout << "texture not setup yet, fail to load ptr to texture" << std::endl;
			#endif
			return 0;
		}

		if( pack_size != 4 ){
			glPushClientAttrib(GL_CLIENT_PIXEL_STORE_BIT);
			glPixelStorei(GL_UNPACK_ALIGNMENT, pack_size);
		}
		if (stride)
			glPixelStorei(GL_UNPACK_ROW_LENGTH, stride);

		Bind();
		glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, tex_width, tex_height, tex_format, mem_type, tex_ptr);
		UnBind();

		if( pack_size != 4 ){
			glPopClientAttrib();
		}
		glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);

		return 1;
	}

	/**
		update a sub region of the texture
	*/
	inline int UpdateSubTexture(
		int		offset_x,
		int		offset_y,
		int		sub_width,
		int		sub_height,
		int		sub_stride,
		void*	sub_texture_ptr,
		GLenum	format = GL_RGB,
		GLenum	memory_type = GL_FLOAT
	) {
		if (!(status & TEXTURE_STATUS_BIT_SETUP_PTR)) {
			std::cout << "error: Texture::UpdateSubTexture, texture not setup yet" << std::endl;
			return 0;
		}

		if (offset_x >= tex_width || offset_y >= tex_height || offset_x + sub_width < 0 || offset_y + sub_height < 0)
			return 1;

		tex_format = format;
		mem_type = memory_type;

		//	calculate pack size for alignment
		if (format == GL_RGBA || mem_type == GL_FLOAT)
			pack_size = 4;
		else if (format == GL_RGB)
			pack_size = (tex_width * 3 % 4 ? ((tex_width * 3 % 2 ? 1 : 2)) : 4);
		else {
			if (tex_width % 4 == 0)
				pack_size = 4;
			else if (tex_width % 2 == 0) {
				pack_size = 2;
			}
			else
				pack_size = 1;
		}

		status |= TEXTURE_STATUS_BIT_SETUP_PTR;

		if (pack_size != 4) {
			glPushClientAttrib(GL_CLIENT_PIXEL_STORE_BIT);
			glPixelStorei(GL_UNPACK_ALIGNMENT, pack_size);
		}
		if (stride)
			glPixelStorei(GL_UNPACK_ROW_LENGTH, stride);

		//	update the sub texture
		Bind();
		glTexSubImage2D(
			GL_TEXTURE_2D, 
			0, 
			offset_x, 
			offset_y, 
			sub_width, 
			sub_height, 
			tex_format, 
			mem_type, 
			sub_texture_ptr);
		UnBind();

		if (pack_size != 4) {
			glPopClientAttrib();
		}
		glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);

		return 1;
	}

	/**
	update a sub region of the texture
	*/
	inline int UpdateSubTexture(
		int		offset_x,
		int		offset_y,
		int		sub_width,
		int		sub_height,
		void*	sub_texture_ptr,
		GLenum	format = GL_RGB,
		GLenum	memory_type = GL_FLOAT
	) {
		return UpdateSubTexture(
			offset_x,
			offset_y,
			sub_width,
			sub_height,
			0,
			sub_texture_ptr,
			format,
			memory_type);
	}

	/**
		delete texture
	*/
	inline int DeleteTexture(){
		if( !(status & TEXTURE_STATUS_BIT_CREATED) ){
			#ifndef BE_QUIET
				std::cout << "texture not created yet, fail to delete texture" << std::endl;
			#endif
			return 0;
		}

		glDeleteTextures(1, &tex_id);

		Reset();

		return 1;
	}

	/**
		Bind texture of given id
	*/
	inline void Bind(){
		glEnable(GL_TEXTURE_2D);
		glBindTexture(GL_TEXTURE_2D, tex_id);
	}

	/**
		UnBind the texture
	*/
	inline void UnBind(){
		glBindTexture(GL_TEXTURE_2D, 0);
	}

	/**
		Get the status of current txture
	*/
	inline int Status(){
		return status;
	}

protected:
	int status;
	enum{
		TEXTURE_STATUS_BIT_CREATED		= 0x01,
		TEXTURE_STATUS_BIT_SETUP_PTR	= 0x02
	};

	inline void Reset(){
		tex_id		= 0;
		tex_width	= 0;
		tex_height	= 0;
		tex_ptr		= NULL;
		tex_internal_format	= GL_RGB;
		tex_format	= GL_RGB;
		mem_type	= GL_FLOAT;
		stride		= 0;
		pack_size	= 1;

		status		= 0;
	}
};


}}	//	end namespace yz::opengl


#endif	//	__YZ_TEXTURE_H__