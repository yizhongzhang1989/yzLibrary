/***********************************************************/
/**	\file
	\brief		UI Window for simple demo using GLUT
	\details	The purpose of this file is to make it easier
				to visualize data for small demos, so you 
				shouldn't try to build any complex visualizing 
				system using classes in this file. \n
				These classes don't have strong error tolerance,
				so you must be very careful using them. \n
				Almost all members are public, this gives you more
				freedom to modify the classes.

				First instance a DemoWindowManager instance as the idle
				function manager. Create GLUTWindowX according to your need,
				register idle function, then enter main loop
	\author		Yizhong Zhang
	\date		6/22/2012
*/
/***********************************************************/
#ifndef __YZ_GLUT_WINDOW_H__
#define __YZ_GLUT_WINDOW_H__

#include "yzLib/yz_setting.h"

#if !(defined(YZ_glut_h) || defined(YZ_freeglut_h) )
#	error yz_demo_window.h must be included after glut.h or freeglut.h
#endif

#include <assert.h>
#include <vector>
#include <iostream>
#include <iomanip>
#include "yzLib/yz_math/yz_vector.h"
#include "yzLib/yz_math/yz_matrix.h"
#include "yzLib/yz_opengl/yz_opengl_utils.h"
#include "yzLib/yz_opengl/yz_texture.h"

namespace yz{	namespace opengl{

/**
	GLUT Window manager

	it is recommended to instance this class with DemoWindowManager

	This class contain a idle function list. call AddIdleFunc() to 
	add new idle functions to this list. Then, call EnterMainLoop() 
	to register the idle function to opengl and call glutMainLoop().

	It is possible to dynamically change idle function list. If you 
	don't need a function any more, just set the pointer to NULL, the
	system will remove it. 
	
	It is highly recommended to always insert new idle function to 
	the end after calling EnterMainLoop(), or it will suffer some
	potential mistakes

	\snippet	glut_window.cpp	Window Manager Setup
*/
template<int ID>
class GLUTWindowManager{
public:
	static std::vector<void (*)(void)> idle_func;

public:
	/**
		constructor, insure only one instance with ID=0 exist
	*/
	GLUTWindowManager(){
		if( ID != 0 ){
			std::cout << "type must be DemoWindowManager, whose ID = 0" << std::endl;
			exit(0);
		}
		if( instance_counter > 0 ){
			std::cout << "only one instance of DemoWindowManager allowed" << std::endl;
			exit(0);
		}
		instance_counter ++;
	}

	/**
		Insert a new idle function into the list

		\param	idle	the idle function to insert
	*/
	inline void AddIdleFunc(void (*idle)(void)){
		idle_func.push_back(idle);
	}

	/**
		Register glutIdleFunc with DefaultIdleFunc and enter glutMainLoop
	*/
	inline void EnterMainLoop(){
		glutIdleFunc(DefaultIdleFunc);
		glutMainLoop();
	}

	/**
		The default idleFunc for glutIdleFunc()

		All idle functions are executed according to their adding sequence
	*/
	static void DefaultIdleFunc(){
		//	execute each item in sequence
		for( int i=0; i<idle_func.size(); i++ )
			if( idle_func[i] )
				(*idle_func[i])();

		//	remove NULL items
		for( int i=0; i<idle_func.size(); i++ ){
			if( idle_func[i] == NULL ){
				idle_func.erase(idle_func.begin() + i);
				i--;
			}
		}
	}

private:
	static int instance_counter;
};

/**
	\example	glut_window.cpp

	This example demonstrates how to create GLUTWindow of 2D, 3D and Texture
	to visualize data and use DemoWindowManager to manage idle functions. 
	FBO is used to transfer display from one window to another.
*/
template<int ID> std::vector<void (*)(void)> GLUTWindowManager<ID>::idle_func;
template<int ID> int GLUTWindowManager<ID>::instance_counter = 0;

/**
	GLUT Window abstract class with ID

	The ID of each window should be unique, this will be guarenteed at runtime

	This class contain basic window information: position, size; 
	OpenGL call back function pointers; mouse variables and other related information.

	CreateGLUTWindow() must be inherited to create a window
*/
template<int ID>
class BaseGLUTWindow{
public:
	//	Window parameters
	static GLint win_id;				///<	window id generated by calling glutCreateWindow
	static int win_x, win_y;			///<	position of the window
	static int win_width, win_height;	///<	size of the window
	static int old_x, old_y;			///<	old position of the mouse
	static int mouse_state[3];			///<	state of the mouse
	static int modifier;				///<	modifier of keyboard, ctrl, alt, shift status

	//	control parameters
	static int auto_swap_buffers;		///<	whether call glutSwapBuffers() in displayFunc

	//	OpenGL Callback Function Pointers
	//	If you want to use your own callback function, just reset the value of them
	static void (*displayFunc)			(void);
	static void (*overlayDisplayFunc)	(void);	
	static void (*reshapeFunc)			(int width, int height);
	static void (*keyboardFunc)			(unsigned char key, int x, int y);
	static void (*mouseFunc)			(int button, int state, int x, int y);
	static void (*motionFunc)			(int x, int y);
	static void (*passiveMotionFunc)	(int x, int y);
	static void (*visibilityFunc)		(int state);
	static void (*entryFunc)			(int state);
	static void (*specialFunc)			(int key, int x, int y);
	static void (*spaceballMotionFunc)	(int x, int y, int z);
	static void (*spaceballRotateFunc)	(int x, int y, int z);
	static void (*spaceballButtonFunc)	(int button, int state);
	static void (*buttonBoxFunc)		(int button, int state);
	static void (*dialsFunc)			(int dial, int value);
	static void (*tabletMotionFunc)		(int x, int y);
	static void (*tabletButtonFunc)		(int button, int state, int x, int y);
	static void (*menuStatusFunc)		(int status, int x, int y);
	static void (*menuStateFunc)		(int status);
	static void (*idleFunc)				(void);
	static void (*timerFunc)			(int value);	

public:
	/**
		Constructor

		First check whether a window using the same ID has been created,
		if so, print error information and exit. It would be better if 
		this can be checked at compile time.

		position and size of the window must be set at construction time
	*/
	BaseGLUTWindow(int x=0, int y=0, int width=800, int height=600) {
		if( window_instance_counter != 0 ){
			std::cout << "More than one BaseGLUTWindow<" << ID << "> instance defined" << std::endl;
			exit(0);	//	This error is caused by hard code error, so exit directly
		}
		window_instance_counter ++;

		SetWindowPositionSize(x, y, width, height);

		status = 0;

		ResetCallbacksToNULL();
	}

	/**
		Destructor

		It is possible that the user forget to call glutMainLoop(), causing 
		the program to terminate unexpected. So we print help information
		to remind the user of this affair.

		If we terminate the program by exit(), this debug information will
		not appear
	*/
	~BaseGLUTWindow(){
		#ifndef BE_QUIET
			std::cout	<< "glutMainLoop() must be called to display windows" << std::endl
						<< "It's your affair to set glutIdleFunc" << std::endl;
		#endif
	}

	/**
		Reset all the callback pointer to NULL
	*/
	inline void ResetCallbacksToNULL(){
		displayFunc			= NULL;
		overlayDisplayFunc	= NULL;
		reshapeFunc			= NULL;
		keyboardFunc		= NULL;
		mouseFunc			= NULL;
		motionFunc			= NULL;
		passiveMotionFunc	= NULL;
		visibilityFunc		= NULL;
		entryFunc			= NULL;
		specialFunc			= NULL;
		spaceballMotionFunc	= NULL;
		spaceballRotateFunc	= NULL;
		spaceballButtonFunc	= NULL;
		buttonBoxFunc		= NULL;
		dialsFunc			= NULL;
		tabletMotionFunc	= NULL;
		tabletButtonFunc	= NULL;
		menuStatusFunc		= NULL;
		menuStateFunc		= NULL;
		idleFunc			= NULL;
		timerFunc			= NULL;
	}

	/**
		Register callback functions to OpenGL
	*/
	inline void RegisterOpenGLCallbacks(){	
		if(displayFunc)			glutDisplayFunc(displayFunc);
		if(overlayDisplayFunc)	glutOverlayDisplayFunc(overlayDisplayFunc);
		if(reshapeFunc)			glutReshapeFunc(reshapeFunc);
		if(keyboardFunc)		glutKeyboardFunc(keyboardFunc);
		if(mouseFunc)			glutMouseFunc(mouseFunc);
		if(motionFunc)			glutMotionFunc(motionFunc);
		if(passiveMotionFunc)	glutPassiveMotionFunc(passiveMotionFunc);
		if(visibilityFunc)		glutVisibilityFunc(visibilityFunc);
		if(entryFunc)			glutEntryFunc(entryFunc);
		if(specialFunc)			glutSpecialFunc(specialFunc);
		if(spaceballMotionFunc)	glutSpaceballMotionFunc(spaceballMotionFunc);
		if(spaceballRotateFunc)	glutSpaceballRotateFunc(spaceballRotateFunc);
		if(spaceballButtonFunc)	glutSpaceballButtonFunc(spaceballButtonFunc);
		if(buttonBoxFunc)		glutButtonBoxFunc(buttonBoxFunc);
		if(dialsFunc)			glutDialsFunc(dialsFunc);
		if(tabletMotionFunc)	glutTabletMotionFunc(tabletMotionFunc);
		if(tabletButtonFunc)	glutTabletButtonFunc(tabletButtonFunc);
		if(menuStatusFunc)		glutMenuStatusFunc(menuStatusFunc);
		if(menuStateFunc)		glutMenuStateFunc(menuStateFunc);
		if(idleFunc)			glutIdleFunc(idleFunc);
		//glutTimerFunc();		//	timer cannot be registered in this way
	}

	/**
		Set Window Title
	*/
	inline void SetWindowTitle(char* window_title){
		glutSetWindow(win_id);
		glutSetWindowTitle(window_title);
	}

	/**
		Set position and size of the window
	*/
	inline void SetWindowPositionSize(int x=0, int y=0, int width=800, int height=600){
		win_x = x;
		win_y = y;
		win_width	= width;
		win_height	= height;
	}

	//	==================================
	//	virtual functions that must inheretent
	//	==================================
	/**
		Create a window using glut

		Before this function, we must setup all the callback functions
		if we want to replace them. After this function, we are able
		to set content aware resources, such as FBO, texture
		
		\snippet	glut_window.cpp	Context awareness	
	*/
	virtual inline void CreateGLUTWindow() = 0;
protected:
	int status;						///<	status guard of the class
	enum{
		GLUT_WINDOW_STATUS_BIT_CREATED = 0x01
	};

private:
	static int window_instance_counter;	///<	how many instances are created of the same ID, increased by constructor
};

template<int ID> int	BaseGLUTWindow<ID>::window_instance_counter	= 0;
template<int ID> GLint	BaseGLUTWindow<ID>::win_id			= 0;
template<int ID> int	BaseGLUTWindow<ID>::win_x			= 0;
template<int ID> int	BaseGLUTWindow<ID>::win_y			= 0;
template<int ID> int	BaseGLUTWindow<ID>::win_width		= 800;
template<int ID> int	BaseGLUTWindow<ID>::win_height		= 600;
template<int ID> int	BaseGLUTWindow<ID>::old_x			= 0;
template<int ID> int	BaseGLUTWindow<ID>::old_y			= 0;
template<int ID> int	BaseGLUTWindow<ID>::mouse_state[3]	= {GLUT_UP, GLUT_UP, GLUT_UP};
template<int ID> int	BaseGLUTWindow<ID>::modifier		= 0;
template<int ID> int	BaseGLUTWindow<ID>::auto_swap_buffers = 1;

template<int ID> void (*BaseGLUTWindow<ID>::displayFunc)		(void)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::overlayDisplayFunc)	(void)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::reshapeFunc)		(int width, int height)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::keyboardFunc)		(unsigned char key, int x, int y)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::mouseFunc)			(int button, int state, int x, int y)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::motionFunc)			(int x, int y)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::passiveMotionFunc)	(int x, int y)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::visibilityFunc)		(int state)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::entryFunc)			(int state)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::specialFunc)		(int key, int x, int y)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::spaceballMotionFunc)(int x, int y, int z)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::spaceballRotateFunc)(int x, int y, int z)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::spaceballButtonFunc)(int button, int state)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::buttonBoxFunc)		(int button, int state)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::dialsFunc)			(int dial, int value)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::tabletMotionFunc)	(int x, int y)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::tabletButtonFunc)	(int button, int state, int x, int y)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::menuStatusFunc)		(int status, int x, int y)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::menuStateFunc)		(int status)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::idleFunc)			(void)	= NULL;
template<int ID> void (*BaseGLUTWindow<ID>::timerFunc)			(int value)	= NULL;


/**
	An OpenGL window used to show 3D objects

	To create a window, create a class with unique ID. Set window
	position and size in constructor, setup your own callback functions,
	then call CreateGLUTWindow() to create a glut window with 3D canvas. 

	For most simple demo windows, just replace *draw callback pointer to
	display your own mesh or other objects. 

	The default constructor enables 6 callbacks:\n
		display		\n
		reshape		\n
		keyboard	\n
		mouse		\n
		motion		\n
		idle

	Three special callback functions are provided:\n
		setLightMaterial,	setup light and material	\n
		draw,				draw objects in the window	\n
		draw_append,		draw objects in the window, called after draw, default NULL \n
	These three callback functions are called sequentially in 
	DefaultDisplayFunc(), just reset them to your own function. 
	DefaultDisplayFunc() take care of matrix. If you replace
	displayFunc callback, then setLightMaterial and draw are no
	longer valid, you must write the whole glutDisplayFunC callback
	yourself. The three special callback functions can be modified at 
	runtime, but be sure that the functions are legal.

	Three picking functions are provided:	\n
		picking_displayFunc,	called in mouseFunc, setup display environment of picking frame	\n 
		picking_draw,			draw each element with sequential color, called in picking_displayFunc	\n
		process_picking,		what to do about the picking	\n
	If you use DefaultMouseFunc, if you left click while pressing Ctrl, 
	color picking will be performed by: first, call picking_displayFunc 
	to draw the picking frame with different color of each element; second,
	pick the pixel color where the mouse has clicked, and transform to index;
	finally, call process_picking to process the picking
*/
template<int ID>
class GLUTWindow3D : public BaseGLUTWindow<ID>{
public:
	static void (*draw) (void);				///<	drawing function without setting OpenGL context, called in DefaultDisplayFunc()
	static void (*draw_append) (void);		///<	optional drawing function, called in DefaultDisplayFunc() after draw, NULL by default
	static void (*setLightMaterial) (void);	///<	setting light and material, called in DefaultDisplayFunc()

	static void (*picking_displayFunc)(void);///<	display function used for picking, similar to display, called in mouseFunc. If you want to disable picking, set to NULL
	static void (*picking_draw) (void);		///<	drawing function used for picking, assign different color for each object
	static void (*process_picking)(int idx);///<	process picking function, called in mouseFunc, defalut NULL

	//	Matrix parameters
	static GLdouble eye_x, eye_y, eye_z;	///<	position of the camera
	static GLdouble spin_x, spin_y;			///<	angle of rotation around x and y axis
	static GLdouble fovy;					///<	field of view of y direction
	static GLdouble z_near, z_far;			///<	clippint plane
	static int				use_arcball_flag;		///<	if this flag is set, we use arcball; otherwise use turntable
	static yz::Matrix4x4d	arcball_mat_col_major;	///<	matrix used by arcball

	//	background
	static GLclampf back_ground_red;		///<	background color red
	static GLclampf back_ground_green;		///<	background color green
	static GLclampf back_ground_blue;		///<	background color blue
	static GLclampf back_ground_alpha;		///<	background color alpha

public:
	/**
		Constructor

		set window parameters according to input, set the callback
		functions to 3D window default functions, including \n
			displayFunc		\n
			reshapeFunc		\n
			keyboardFunc	\n
			mouseFunc		\n
			motionFunc		\n
			idleFunc
	*/
	GLUTWindow3D(int x=0, int y=0, int width=800, int height=600) : BaseGLUTWindow<ID>(x, y, width, height) {
		ResetCallbacksToDefault();
	}

	/**
		Set Draw Callback
	*/
	inline void SetDraw(void (*draw_func)(void)){
		draw = draw_func;
	}

	/**
		Set Draw Append Callback

		It is highly recommended to put printing functions only in draw_append function
	*/
	inline void SetDrawAppend(void (*draw_append_func)(void)){
		draw_append	= draw_append_func;
	}

	/**
		Set Picking Draw Callback
	*/
	inline void SetPickingDraw(void (*picking_draw_func)(void)){
		picking_draw = picking_draw_func;
	}

	/**
		Set Process Picking Function
	*/
	inline void SetProcessPicking(void (*process_picking_func)(int idx)){
		process_picking = process_picking_func;
	}

	/**
		set background color
	*/
	inline void SetBackgroundColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha){
		back_ground_red		= red;
		back_ground_green	= green;
		back_ground_blue	= blue;
		back_ground_alpha	= alpha;
	}

	/**
		Create an OpenGL Window and register callbacks

		By default, once the window is created, it will last until
		the program terminates, and no glut callback can be changed.
		If you want to use your own callback, replace them before calling
		CreateGLUTWindow().

		If you use DefaultDisplayFunc, draw pointer is still able 
		to change after the window created, but be sure to pass a valid
		display function to it, or the program will crash.
	*/
	inline void CreateGLUTWindow() {
		if( this->status & this->GLUT_WINDOW_STATUS_BIT_CREATED )
			return;

		glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA | GLUT_ALPHA);
		glutInitWindowPosition(this->win_x, this->win_y);
		glutInitWindowSize(this->win_width, this->win_height);
		this->win_id = glutCreateWindow("3D Window");

		#ifdef YZ_glew_h
			if( glewInit() != GLEW_OK ){
				std::cout << "Init glew failed calling CreateGLUTWindow3D() of ID: " << ID << std::endl;
				exit(0);
			}
		#endif

		this->RegisterOpenGLCallbacks();

		this->status |= this->GLUT_WINDOW_STATUS_BIT_CREATED;

		arcball_mat_col_major.SetIdentity();
	}


	/**
		set the following function pointers to default 3D display window:\n
			display	\n
			reshape \n
			keyboard\n
			mouse	\n
			motion	\n
			idle	

		set draw to default draw: draw a red teapot

		other function pointers are set to NULL
	*/
	inline void ResetCallbacksToDefault(){
		this->ResetCallbacksToNULL();
		this->displayFunc		= DefaultDisplayFunc;
		this->reshapeFunc		= DefaultReshapeFunc;
		this->keyboardFunc		= DefaultKeyboardFunc;
		this->mouseFunc			= DefaultMouseFunc;
		this->motionFunc		= DefaultMotionFunc;
		this->idleFunc			= DefaultIdleFunc;

		draw				= DefaultDraw;
		draw_append			= NULL;
		setLightMaterial	= DefaultSetLightMaterial;

		picking_displayFunc	= DefaultPickingDisplayFunc;
		picking_draw		= DefaultPickingDraw;
		process_picking		= DefaultProcessPicking;
	}

	/**
		Pick the index of a pixel
	*/
	static int PickingIndex(int x, int y){
		unsigned char rgba[4];

		GLint viewport[4];
		glGetIntegerv(GL_VIEWPORT, viewport);

		glReadPixels(x, viewport[3] - y, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, rgba);

		return getIndexOfSequentialColor(rgba);
	}

	/**
		Pick the depth of a pixel

		Once we get the depth, world coordinate of the picking point can be calculated
		by calling gluUnProject(...). yz::getWorldCoordinate(...) can be used for simplicity
	*/
	static float PickingDepth(int x, int y){
		float depth;

		GLint viewport[4];
		glGetIntegerv(GL_VIEWPORT, viewport);

		glReadPixels(x, viewport[3] - y, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &depth);

		return depth;
	}

	//	========================================
	///@{
	/**	@name Default Callback called in Default OpenGL Callback
	*/
	//	========================================
	/**
		Default draw, coordinate axis and a red teapot
	*/
	static void DefaultDraw(){
		drawXYZAxis();

		glColor3f( 1, 0, 0 );
		glutSolidTeapot( 0.5 );
	}

	/**
		Default set light and material

		light:	amb 0.1, dif 1.0, spe 1.0, pos(10, 20, 5)

		material:	amb 0.1, dif 0.5, spe 1.0
	*/
	static void DefaultSetLightMaterial(){
		//	Light parameters
		GLfloat ambient[] = {0.0, 0.0, 0.0, 1.0};
		GLfloat diffuse[] = {1.0, 1.0, 1.0, 1.0};
		GLfloat specular[] = {1.0, 1.0, 1.0, 1.0};
		GLfloat position[] = {10.0, 20.0, 5.0, 0.0};

		//	Material parameters
		GLfloat material_ambient[] = {0.1, 0.1, 0.1, 1.0};
		GLfloat material_diffuse[] = {0.5, 0.5, 0.5, 1.0};
		//GLfloat material_specular[] = {1.0, 1.0, 1.0, 1.0};
		//GLfloat shineness = 64.0f;
		GLfloat material_specular[] = {0.0, 0.0, 0.0, 1.0};
		GLfloat shineness = 0.0f;

		//	setup light
		glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
		glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
		glLightfv(GL_LIGHT0, GL_SPECULAR, specular);

		//	set light position, we set the light to be rotation free with mouse
		assert( !isMatrixStackFull(GL_MODELVIEW) );

		glMatrixMode(GL_MODELVIEW);
		glPushMatrix();
		glLoadIdentity();
		glLightfv(GL_LIGHT0, GL_POSITION, position);
		glPopMatrix();

		//	set material
		glEnable(GL_COLOR_MATERIAL);
		glMaterialfv(GL_FRONT, GL_AMBIENT, material_ambient);
		glMaterialfv(GL_FRONT, GL_DIFFUSE, material_diffuse);
		glMaterialfv(GL_FRONT, GL_SPECULAR, material_specular);
		glMaterialf(GL_FRONT, GL_SHININESS, shineness);
	}

	/**
		Picking Display, called in Mouse Func

		Setup the enviromnent by disable all attributes that could 
		cause the color to change, then call picking_draw. \n
		When you want to perform color picking, call this function to 
		create a color map, then pick the color.
	*/
	static void DefaultPickingDisplayFunc(){
		if(!picking_draw)	return;		//	picking is disabled

		assert( !isAttributeStackFull() );
		assert( !isMatrixStackFull(GL_MODELVIEW) );

		glPushAttrib(GL_ALL_ATTRIB_BITS);
		glMatrixMode(GL_MODELVIEW);
		glPushMatrix();

		//	========================================================
		//	Display function inside this segment

		//	disable lighting, texture, ...
		glDisable(GL_LIGHTING);
		glDisable(GL_TEXTURE_2D);
		glDisable(GL_FOG);
		glDisable(GL_BLEND);
		glDisable(GL_DITHER);
		glShadeModel(GL_FLAT);

		//	set background color
		unsigned char background_color[4];	//	we set the background color to be color of index -1
		getSequentialColor(background_color, 0xFFFFFFFF);
		glClearColor(
			background_color[0]/255.0f, 
			background_color[1]/255.0f, 
			background_color[2]/255.0f, 
			background_color[3]/255.0f );
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		//	Setup Modelview Matrix, must be the same as that called in displayFunc
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		gluLookAt( eye_x, eye_y, eye_z, eye_x, eye_y, eye_z-1, 0, 1, 0 );

		if (use_arcball_flag){	//	arcball
			glMultMatrixd(arcball_mat_col_major.data[0]);
		}
		else{					//	turn table
			glRotatef(spin_y, 1, 0, 0);
			glRotatef(spin_x, 0, 1, 0);
		}

		//	draw function, we don't check whether draw and picking_draw match
		if(picking_draw)	(*picking_draw)();

		//	========================================================

		glPopMatrix();
		glPopAttrib();
	}

	/**
		Default picking drawing

		draw the teapot with 0 index
	*/
	static void DefaultPickingDraw(){
		setPickingIndex(0);
		glutSolidTeapot( 0.5 );
	}

	/**
		Default process picking 

		print the index
	*/
	static void DefaultProcessPicking(int idx){
		std::cout << "Picking index: 0x" << std::setfill('0') << std::setw(8) 
			<< std::hex << std::uppercase << idx << std::dec << std::nouppercase << std::endl;
	}

	///@}

	//	========================================
	///@{
	/**	@name Default OpenGL Callback Functions
	*/
	//	========================================
	/**
		Default display, setup the matrix and call draw

		Only model view matrix is reset by default
	*/
	static void DefaultDisplayFunc(){
		glEnable(GL_DEPTH_TEST);
		glEnable(GL_LIGHTING);
		glEnable(GL_LIGHT0);
		glShadeModel(GL_SMOOTH);

		glClearColor(back_ground_red, back_ground_green, back_ground_blue, back_ground_alpha);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		//	Setup Modelview Matrix
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		gluLookAt( eye_x, eye_y, eye_z, eye_x, eye_y, eye_z-1, 0, 1, 0 );

		if (use_arcball_flag){	//	arcball
			glMultMatrixd(arcball_mat_col_major.data[0]);
		}
		else{					//	turn table
			glRotatef(spin_y, 1, 0, 0);
			glRotatef(spin_x, 0, 1, 0);
		}

		if(setLightMaterial)	(*setLightMaterial)();
		if(draw)				(*draw)();
		if(draw_append)			(*draw_append)();

		if (BaseGLUTWindow<ID>::auto_swap_buffers)
			glutSwapBuffers();
	}

	/**
		Reshape

		Another usage is to pass win_width and win_height to this function,
		so the projection matrix will be reset

		Projection matrix will be updated
	*/
	static void DefaultReshapeFunc(int w, int h){

		BaseGLUTWindow<ID>::win_width = w;
		BaseGLUTWindow<ID>::win_height = h;

		//	Setup Projection Matrix
		glViewport(0, 0, BaseGLUTWindow<ID>::win_width, BaseGLUTWindow<ID>::win_height);
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		gluPerspective(fovy, (float)BaseGLUTWindow<ID>::win_width/(float)BaseGLUTWindow<ID>::win_height, z_near, z_far);

		//	set back to model view
		glMatrixMode(GL_MODELVIEW);
	}

	/**
		Keyboard call back, exit when press ESC
	*/
	static void DefaultKeyboardFunc(unsigned char key, int x, int y){
		switch( key ){
			case 27:
				exit(0);
		}

		glutPostRedisplay();
	}

	/**
		Record mouse click

		If Ctrl is pressed and picking is enable, then perform picking
	*/
	static void DefaultMouseFunc(int button, int state, int x, int y){
		BaseGLUTWindow<ID>::mouse_state[button] = state;
		BaseGLUTWindow<ID>::old_x = x;
		BaseGLUTWindow<ID>::old_y = y;
		BaseGLUTWindow<ID>::modifier = glutGetModifiers();

		//	if picking_displayFunc is set and Ctrl is pressed, then perform color picking
		if( picking_displayFunc && (BaseGLUTWindow<ID>::modifier&GLUT_ACTIVE_CTRL) && BaseGLUTWindow<ID>::mouse_state[GLUT_LEFT_BUTTON]==GLUT_DOWN ){
			//	check whether picking is legal
			int picking_legal = 0;

			//	picking_displayFunc has been changed, then we know the user has specifically written the function
			if( picking_displayFunc != DefaultPickingDisplayFunc )
				picking_legal = 1;
			//	picking_displayFunc is not changed, but picking_draw is changed, legal
			else if( picking_draw && picking_draw != DefaultPickingDraw )
				picking_legal = 1;
			//	picking is default function, then only display functions are default, can picking be legal
			else if(BaseGLUTWindow<ID>::displayFunc==DefaultDisplayFunc && draw==DefaultDraw )
				picking_legal = 1;

			if( picking_legal ){
				(*picking_displayFunc)();
				int index = PickingIndex(x, y);
				if(process_picking)	(*process_picking)(index);
			}
		}

		glutPostRedisplay();
	}

	/**
		Reset eye and spin according to mouse motion

		If Shift buttun is pressed, then moving on left button is
		used to translate instead of rotate. This is for notebook
		without middle button.
	*/
	static void DefaultMotionFunc(int x, int y){
		if(BaseGLUTWindow<ID>::mouse_state[GLUT_LEFT_BUTTON] == GLUT_DOWN ){
			if(BaseGLUTWindow<ID>::modifier & GLUT_ACTIVE_SHIFT ){
				eye_x -= float( x - BaseGLUTWindow<ID>::old_x ) / 20;
				eye_y += float( y - BaseGLUTWindow<ID>::old_y ) / 20;
			}
			else{
				if (use_arcball_flag){	//	rotate the scene by arcball
					if (x != BaseGLUTWindow<ID>::old_x || y != BaseGLUTWindow<ID>::old_y) {
						yz::Vec3d va = GetArcballVector(BaseGLUTWindow<ID>::old_x, BaseGLUTWindow<ID>::old_y);
						yz::Vec3d vb = GetArcballVector(x, y);
						double angle = acos(yz::myMin(1.0, yz::dot(va, vb)));
						yz::Vec3d axis_in_camera_coord = yz::cross(va, vb);

						yz::Matrix4x4d rot_step;
						rot_step.SetRotationRad(axis_in_camera_coord, angle);
						rot_step.SetTranspose();

						arcball_mat_col_major = arcball_mat_col_major * rot_step;
					}
				}
				else{					//	rotate the scene by turntable
					spin_x += float(x - BaseGLUTWindow<ID>::old_x);
					spin_y += float(y - BaseGLUTWindow<ID>::old_y);
				}
			}
		}
		else if(BaseGLUTWindow<ID>::mouse_state[GLUT_MIDDLE_BUTTON] == GLUT_DOWN ){
			eye_x -= float( x - BaseGLUTWindow<ID>::old_x ) / 20;
			eye_y += float( y - BaseGLUTWindow<ID>::old_y ) / 20;
		}
		else if(BaseGLUTWindow<ID>::mouse_state[GLUT_RIGHT_BUTTON] == GLUT_DOWN ){
			eye_z += float( y - BaseGLUTWindow<ID>::old_y ) / 10;
		}

		BaseGLUTWindow<ID>::old_x = x;
		BaseGLUTWindow<ID>::old_y = y;
		glutPostRedisplay();
	}

	/**
		Default idle, refresh the window
	*/
	static void DefaultIdleFunc(){
		glutSetWindow(BaseGLUTWindow<ID>::win_id);
		glutPostRedisplay();
	}

	///@}

	static yz::Vec3d GetArcballVector(int x, int y){
		yz::Vec3d P = yz::Vec3d(
			x / double(BaseGLUTWindow<ID>::win_width) * 2 - 1.0,
			y / double(BaseGLUTWindow<ID>::win_height) * 2 - 1.0,
			0);
		P.y = -P.y;
		double OP_squared = P.x * P.x + P.y * P.y;
		if (OP_squared <= 1.0)
			P.z = sqrt(1.0 - OP_squared);  // Pythagore
		else
			P = P.Normalize();;  // nearest point
		return P;
	}

};
/**
	\example	picking.cpp

	This example performs picking of vertices. Currently picking is only
	implemented in 3D window
*/

template<int ID> void	(*GLUTWindow3D<ID>::draw) (void)				= NULL;
template<int ID> void	(*GLUTWindow3D<ID>::draw_append) (void)			= NULL;
template<int ID> void	(*GLUTWindow3D<ID>::setLightMaterial) (void)	= NULL;
template<int ID> void	(*GLUTWindow3D<ID>::picking_displayFunc) (void)	= NULL;
template<int ID> void	(*GLUTWindow3D<ID>::picking_draw) (void)		= NULL;
template<int ID> void	(*GLUTWindow3D<ID>::process_picking) (int idx)	= NULL;
template<int ID> GLdouble	GLUTWindow3D<ID>::eye_x		= 0;
template<int ID> GLdouble	GLUTWindow3D<ID>::eye_y		= 0;
template<int ID> GLdouble	GLUTWindow3D<ID>::eye_z		= 3;
template<int ID> GLdouble	GLUTWindow3D<ID>::spin_x	= 0;
template<int ID> GLdouble	GLUTWindow3D<ID>::spin_y	= 0;
template<int ID> GLdouble	GLUTWindow3D<ID>::fovy		= 45;
template<int ID> GLdouble	GLUTWindow3D<ID>::z_near	= 0.1;
template<int ID> GLdouble	GLUTWindow3D<ID>::z_far		= 100;
template<int ID> int		GLUTWindow3D<ID>::use_arcball_flag	= 0;
template<int ID> yz::Matrix4x4d	GLUTWindow3D<ID>::arcball_mat_col_major;
template<int ID> GLclampf	GLUTWindow3D<ID>::back_ground_red	= 0.0;
template<int ID> GLclampf	GLUTWindow3D<ID>::back_ground_green	= 0.0;
template<int ID> GLclampf	GLUTWindow3D<ID>::back_ground_blue	= 0.0;
template<int ID> GLclampf	GLUTWindow3D<ID>::back_ground_alpha	= 0.0;


/**
	An OpenGL window used to show 2D objects

	To create a window, create a class with unique ID. Set window
	position and size in constructor, setup your own callback functions,
	then call CreateGLUTWindow() to create a glut window with 2D canvas. 

	For most simple demo windows, just replace *draw callback pointer to
	display your own mesh or other objects. 

	The default constructor enables 6 callbacks:\n
		display		\n
		reshape		\n
		keyboard	\n
		mouse		\n
		motion		\n
		idle		\n
	Two special callback functions are provided:\n
		draw,				draw objects in the window	\n
		draw_append,		draw objects in the window, called after draw, default NULL\n
	DefaultDisplayFunc() take care of matrix. If you replace
	displayFunc callback, then draw is no longer valid, you 
	must write the whole glutDisplayFunC callback yourself. 
	draw callback functions can be modified at runtime, 
	but be sure that the function is legal.

	Three picking functions are provided(same as GLUTWindow3D):	\n
		picking_displayFunc,	called in mouseFunc, setup display environment of picking frame	\n 
		picking_draw,			draw each element with sequential color, called in picking_displayFunc	\n
		process_picking,		what to do about the picking	\n
	If you use DefaultMouseFunc, if you left click while pressing Ctrl, 
	color picking will be performed by: first, call picking_displayFunc 
	to draw the picking frame with different color of each element; second,
	pick the pixel color where the mouse has clicked, and transform to index;
	finally, call process_picking to process the picking
*/
template<int ID>
class GLUTWindow2D : public BaseGLUTWindow<ID>{
public:
	static void (*draw) (void);				///<	drawing function without setting OpenGL context, called in DefaultDisplayFunc()
	static void (*draw_append) (void);		///<	optional drawing function, called in DefaultDisplayFunc() after draw, NULL by default

	static void (*picking_displayFunc)(void);///<	display function used for picking, similar to display, called in mouseFunc. If you want to disable picking, set to NULL
	static void (*picking_draw) (void);		///<	drawing function used for picking, assign different color for each object
	static void (*process_picking)(int idx);///<	process picking function, called in mouseFunc, defalut NULL

	//	Matrix parameters
	static GLdouble left, right, bottom, top;

	//	background
	static GLclampf back_ground_red;		///<	background color red
	static GLclampf back_ground_green;		///<	background color green
	static GLclampf back_ground_blue;		///<	background color blue
	static GLclampf back_ground_alpha;		///<	background color alpha

public:
	/**
		Constructor

		set window parameters according to input, set the callback
		functions to 3D window default functions, including \n
			displayFunc		\n
			reshapeFunc		\n
			keyboardFunc	\n
			mouseFunc		\n
			motionFunc		\n
			idleFunc
	*/
	GLUTWindow2D(int x=0, int y=0, int width=800, int height=600) : BaseGLUTWindow<ID>(x, y, width, height) {
		ResetCallbacksToDefault();
	}

	/**
		Set Draw Callback
	*/
	inline void SetDraw(void (*draw_func)(void)){
		draw = draw_func;
	}

	/**
		Set Draw Append Callback
	*/
	inline void SetDrawAppend(void (*draw_append_func)(void)){
		draw_append	= draw_append_func;
	}

	/**
		Set Picking Draw Callback
	*/
	inline void SetPickingDraw(void (*picking_draw_func)(void)){
		picking_draw = picking_draw_func;
	}

	/**
		Set Process Picking Function
	*/
	inline void SetProcessPicking(void (*process_picking_func)(int idx)){
		process_picking = process_picking_func;
	}

	/**
		set background color
	*/
	inline void SetBackgroundColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha){
		back_ground_red		= red;
		back_ground_green	= green;
		back_ground_blue	= blue;
		back_ground_alpha	= alpha;
	}

	/**
		Reset the coordinate of boarder
	*/
	inline void ResetBoarderCoordinate(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top){
		this->left		= left;
		this->right		= right;
		this->bottom	= bottom;
		this->top		= top;
		DefaultReshapeFunc(this->in_width, this->win_height);
	}

	/**
		Create an OpenGL Window and register callbacks

		By default, once the window is created, it will last until
		the program terminates, and no glut callback can be changed.
		If you want to use your own callback, replace them before calling
		CreateGLUTWindow().

		If you use DefaultDisplayFunc(), draw pointer is still able 
		to change after the window created, but be sure to pass a valid
		display function to it, or the program will crash.
	*/
	inline void CreateGLUTWindow() {
		if( this->status & this->GLUT_WINDOW_STATUS_BIT_CREATED )
			return;

		glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
		glutInitWindowPosition(this->win_x, this->win_y);
		glutInitWindowSize(this->win_width, this->win_height);
		this->win_id = glutCreateWindow("2D Window");

		#ifdef YZ_glew_h
			if( glewInit() != GLEW_OK ){
				std::cout << "Init glew failed calling CreateGLUTWindow3D() of ID: " << ID << std::endl;
				exit(0);
			}
		#endif

		this->RegisterOpenGLCallbacks();

		this->status |= this->GLUT_WINDOW_STATUS_BIT_CREATED;
	}

	/**
		set the following function pointers to default 3D display window:\n
			display	\n
			reshape \n
			keyboard\n
			mouse	\n
			motion	\n
			idle	

		set draw to default draw: draw square

		other function pointers are set to NULL
	*/
	inline void ResetCallbacksToDefault(){
		this->ResetCallbacksToNULL();
		this->displayFunc	= DefaultDisplayFunc;
		this->reshapeFunc	= DefaultReshapeFunc;
		this->keyboardFunc	= DefaultKeyboardFunc;
		this->mouseFunc		= DefaultMouseFunc;
		this->motionFunc	= DefaultMotionFunc;
		this->idleFunc		= DefaultIdleFunc;

		draw				= DefaultDraw;
		draw_append			= NULL;

		picking_displayFunc	= DefaultPickingDisplayFunc;
		picking_draw		= DefaultPickingDraw;
		process_picking		= DefaultProcessPicking;
	}

	/**
		Pick the index of a pixel
	*/
	static int PickingIndex(int x, int y){
		unsigned char rgba[4];

		GLint viewport[4];
		glGetIntegerv(GL_VIEWPORT, viewport);

		glReadPixels(x, viewport[3] - y, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, rgba);

		return getIndexOfSequentialColor(rgba);
	}

	/**
		calculate the coordinate of a pixel

		\param	coor_x		return the x coordinate in window coordinate system
		\param	coor_y		return the y coordinate in window coordinate system
		\param	x			pixel x, left is zero
		\param	y			pixel y, top is zero
	*/
	static void CalculateCoordinate(float& coor_x, float& coor_y, int x, int y){
		coor_x = left + (right - left) * x / BaseGLUTWindow<ID>::win_width;
		coor_y = bottom + (top - bottom) * y / BaseGLUTWindow<ID>::win_height;
	}

	/**
		calculate the coordinate of a pixel

		\param	coor_x		return the x coordinate in window coordinate system
		\param	coor_y		return the y coordinate in window coordinate system
		\param	x			pixel x, left is zero
		\param	y			pixel y, top is zero
	*/
	static void CalculateCoordinate(double& coor_x, double& coor_y, int x, int y){
		coor_x = left + (right - left) * x / BaseGLUTWindow<ID>::win_width;
		coor_y = top + (bottom - top) * y / BaseGLUTWindow<ID>::win_height;
	}

	//	==========================================================
	//	Default Callback Functions
	//	==========================================================
	/**
		Default draw, simple object
	*/
	static void DefaultDraw(){
		glBegin( GL_QUADS );
			glColor3f(1, 0, 0);	glVertex2f( 0.1, 0.1 );
			glColor3f(0, 1, 0);	glVertex2f( 0.5, 0.1 );
			glColor3f(0, 0, 1);	glVertex2f( 0.5, 0.3 );
			glColor3f(0, 0, 0);	glVertex2f( 0.1, 0.4 );
		glEnd();
	}

	/**
		Picking Display, called in Mouse Func

		Setup the enviromnent by disable all attributes that could 
		cause the color to change, then call picking_draw. \n
		When you want to perform color picking, call this function to 
		create a color map, then pick the color.
	*/
	static void DefaultPickingDisplayFunc(){
		if(!picking_draw)	return;		//	picking is disabled

		assert( !isAttributeStackFull() );
		assert( !isMatrixStackFull(GL_MODELVIEW) );

		glPushAttrib(GL_ALL_ATTRIB_BITS);
		glMatrixMode(GL_MODELVIEW);
		glPushMatrix();

		//	========================================================
		//	Display function inside this segment

		//	disable lighting, texture, ...
		glDisable(GL_LIGHTING);
		glDisable(GL_TEXTURE_2D);
		glDisable(GL_FOG);
		glDisable(GL_BLEND);
		glDisable(GL_DITHER);
		glShadeModel(GL_FLAT);

		//	set background color
		unsigned char background_color[4];	//	we set the background color to be color of index -1
		getSequentialColor(background_color, 0xFFFFFFFF);
		glClearColor(
			background_color[0]/255.0f, 
			background_color[1]/255.0f, 
			background_color[2]/255.0f, 
			background_color[3]/255.0f );
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		//	Setup Modelview Matrix
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();

		//	draw function, we don't check whether draw and picking_draw match
		if(picking_draw)	(*picking_draw)();

		//	========================================================

		glPopMatrix();
		glPopAttrib();
	}

	/**
		Default picking drawing

		draw the teapot with 0 index
	*/
	static void DefaultPickingDraw(){
		setPickingIndex(0);
		glBegin( GL_QUADS );
			glVertex2f( 0.1, 0.1 );
			glVertex2f( 0.5, 0.1 );
			glVertex2f( 0.5, 0.3 );
			glVertex2f( 0.1, 0.4 );
		glEnd();
	}

	/**
		Default process picking 

		print the index
	*/
	static void DefaultProcessPicking(int idx){
		std::cout << "Picking index: 0x" << std::setfill('0') << std::setw(8) 
			<< std::hex << std::uppercase << idx << std::dec << std::nouppercase << std::endl;
	}

	/**
		Default display, setup the matrix and call draw

		only model view matrix will be modified
	*/
	static void DefaultDisplayFunc(){
		glClearColor(back_ground_red, back_ground_green, back_ground_blue, back_ground_alpha);
		glClear( GL_COLOR_BUFFER_BIT );

		//	Setup Modelview Matrix
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();

		if(draw)		(*draw)();
		if(draw_append)	(*draw_append)();

		if (BaseGLUTWindow<ID>::auto_swap_buffers)
			glutSwapBuffers();
	}

	/**
		Reshape

		projection matrix will be updated
	*/
	static void DefaultReshapeFunc(int w, int h){
		BaseGLUTWindow<ID>::win_width = w;
		BaseGLUTWindow<ID>::win_height = h;

		GLdouble center_y = (bottom + top) / 2;
		GLdouble height = (right - left) * h / w;
		bottom	= center_y - height / 2;
		top		= bottom + height;

		//	Setup Projection Matrix
		glViewport(0, 0, BaseGLUTWindow<ID>::win_width, BaseGLUTWindow<ID>::win_height);
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		gluOrtho2D(left, right, bottom, top);

		//	set back to model view
		glMatrixMode(GL_MODELVIEW);
	}

	/**
		Keyboard call back, exit when press ESC
	*/
	static void DefaultKeyboardFunc(unsigned char key, int x, int y){
		switch( key ){
			case 27:
				exit(0);
			case 'r':
				left	= 0;
				right	= 1;
				bottom	= 0;
				top		= 1;
				DefaultReshapeFunc(BaseGLUTWindow<ID>::win_width, BaseGLUTWindow<ID>::win_height);
				break;
		}

		glutPostRedisplay();
	}

	/**
		Record mouse click
	*/
	static void DefaultMouseFunc(int button, int state, int x, int y){
		BaseGLUTWindow<ID>::mouse_state[button] = state;
		BaseGLUTWindow<ID>::old_x = x;
		BaseGLUTWindow<ID>::old_y = y;
		BaseGLUTWindow<ID>::modifier = glutGetModifiers();

		//	if picking_displayFunc is set and Ctrl is pressed, then perform color picking
		if( picking_displayFunc && (BaseGLUTWindow<ID>::modifier&GLUT_ACTIVE_CTRL) && BaseGLUTWindow<ID>::mouse_state[GLUT_LEFT_BUTTON]==GLUT_DOWN ){
			//	check whether picking is legal
			int picking_legal = 0;

			//	picking_displayFunc has been changed, then we know the user has specifically written the function
			if( picking_displayFunc != DefaultPickingDisplayFunc )
				picking_legal = 1;
			//	picking_displayFunc is not changed, but picking_draw is changed, legal
			else if( picking_draw && picking_draw != DefaultPickingDraw )
				picking_legal = 1;
			//	picking is default function, then only display functions are default, can picking be legal
			else if(BaseGLUTWindow<ID>::displayFunc==DefaultDisplayFunc && draw==DefaultDraw )
				picking_legal = 1;

			if( picking_legal ){
				(*picking_displayFunc)();
				int index = PickingIndex(x, y);
				if(process_picking)	(*process_picking)(index);
			}
		}

		glutPostRedisplay();
	}

	/**
		reset boarder coordinate of 3D canvas

		both left and middle button are used for move incase notepad don't have middle button
	*/
	static void DefaultMotionFunc(int x, int y){
		if(BaseGLUTWindow<ID>::mouse_state[GLUT_LEFT_BUTTON] == GLUT_DOWN ){			//	move
			GLdouble width	= right - left;
			GLdouble height	= top - bottom;
			GLdouble move_x = - width * GLdouble(x- BaseGLUTWindow<ID>::old_x)/ BaseGLUTWindow<ID>::win_width;
			GLdouble move_y = height * GLdouble(y- BaseGLUTWindow<ID>::old_y)/ BaseGLUTWindow<ID>::win_height;
			left	+= move_x;
			right	+= move_x;
			bottom	+= move_y;
			top		+= move_y;
			(*BaseGLUTWindow<ID>::reshapeFunc)(BaseGLUTWindow<ID>::win_width, BaseGLUTWindow<ID>::win_height);
		}
		else if(BaseGLUTWindow<ID>::mouse_state[GLUT_MIDDLE_BUTTON] == GLUT_DOWN ){	//	move
			GLdouble width	= right - left;
			GLdouble height	= top - bottom;
			GLdouble move_x = - width * GLdouble(x- BaseGLUTWindow<ID>::old_x)/ BaseGLUTWindow<ID>::win_width;
			GLdouble move_y = height * GLdouble(y- BaseGLUTWindow<ID>::old_y)/ BaseGLUTWindow<ID>::win_height;
			left	+= move_x;
			right	+= move_x;
			bottom	+= move_y;
			top		+= move_y;
			(*BaseGLUTWindow<ID>::reshapeFunc)(BaseGLUTWindow<ID>::win_width, BaseGLUTWindow<ID>::win_height);
		}
		else if(BaseGLUTWindow<ID>::mouse_state[GLUT_RIGHT_BUTTON] == GLUT_DOWN ){		//	scale
			GLdouble width	= right - left;
			GLdouble height	= top - bottom;
			GLdouble center_x = (left + right) / 2;
			GLdouble center_y = (bottom + top) / 2;
			GLdouble zoom = 1 + GLdouble(y- BaseGLUTWindow<ID>::old_y)/200;
			width	*= zoom;
			height	*= zoom;
			left	= center_x - width / 2;
			right	= center_x + width / 2;
			bottom	= center_y - height / 2;
			top		= center_y + height / 2;
			(*BaseGLUTWindow<ID>::reshapeFunc)(BaseGLUTWindow<ID>::win_width, BaseGLUTWindow<ID>::win_height);
		}

		BaseGLUTWindow<ID>::old_x = x;
		BaseGLUTWindow<ID>::old_y = y;
		glutPostRedisplay();
	}

	/**
		Default idle, refresh the window
	*/
	static void DefaultIdleFunc(){
		glutSetWindow(BaseGLUTWindow<ID>::win_id);
		glutPostRedisplay();
	}
};

template<int ID> void	(*GLUTWindow2D<ID>::draw) (void)		= NULL;
template<int ID> void	(*GLUTWindow2D<ID>::draw_append) (void)	= NULL;
template<int ID> void	(*GLUTWindow2D<ID>::picking_displayFunc) (void)	= NULL;
template<int ID> void	(*GLUTWindow2D<ID>::picking_draw) (void)		= NULL;
template<int ID> void	(*GLUTWindow2D<ID>::process_picking) (int idx)	= NULL;
template<int ID> GLdouble	GLUTWindow2D<ID>::left				= -1;
template<int ID> GLdouble	GLUTWindow2D<ID>::right				= 1;
template<int ID> GLdouble	GLUTWindow2D<ID>::bottom			= -1;
template<int ID> GLdouble	GLUTWindow2D<ID>::top				= 1;
template<int ID> GLclampf	GLUTWindow2D<ID>::back_ground_red	= 1.0;
template<int ID> GLclampf	GLUTWindow2D<ID>::back_ground_green	= 1.0;
template<int ID> GLclampf	GLUTWindow2D<ID>::back_ground_blue	= 1.0;
template<int ID> GLclampf	GLUTWindow2D<ID>::back_ground_alpha	= 1.0;

/**
	a 2D window used to show a texture

	usage of this class is similar to GLUTWindow2D, with
	additional operation of SetupTexturePtr after CreateGLUTWindow.

	call SetupTexturePtr to specify a pointer to the space where
	the image is stored. After this, the pointer is saved. When the 
	image is modified, call LoadPtrToTexture() to refresh the texture
	of OpenGL.

	This class is also a demo showing how to inherent GLUTWindowXD
*/
template<int ID>
class GLUTTextureWindow2D : public GLUTWindow2D<ID> {
public:
	static Texture texture;		///<	the texture to display

	static int flip_flag;		///<	whether vertically flip the texture when drawing

public:
	/**
		constructor
	*/
	GLUTTextureWindow2D(int x=0, int y=0, int width=800, int height=600) : GLUTWindow2D<ID>(x, y, width, height), status(0) {
		this->left	= 0;
		this->right	= 1;
		this->bottom	= 0;
		this->top		= 1;
		DefaultReshapeFunc(this->win_width, this->win_height);

		this->keyboardFunc	= DefaultKeyboardFunc;
		this->draw			= DefaultDraw;

		flip_flag	= 0;
	}

	/**
		Create an OpenGL Window and register callbacks

		create texture instance of OpenGL. This step must be done
		here because texture is only valid for this context, so it must
		be called after glutCreateWindow() and create window of other 
		opengl instances.

		reset keyboard function and draw function with default draw in this class
	*/
	inline void CreateGLUTWindow() {
		GLUTTextureWindow2D<ID>::CreateGLUTWindow();

		texture.CreateTexture();	//	texture must be create here

		status |= GLUT_TEXTURE_WINDOW2D_STATUS_BIT_WINDOW_CREATED;
	}

	/**
		Set Draw Callback
	*/
	inline void SetDraw(void (*draw_func)(void)){
		GLUTTextureWindow2D<ID>::draw = draw_func;
	}
	/**
		Setup texture ptr, in order to load the image to texture
	*/
	inline int SetupTexturePtr(	int width, 
								int height, 
								void* texture_ptr, 
								GLint internal_format = GL_RGB, 
								GLenum format = GL_RGB, 
								GLenum memory_type = GL_FLOAT){
		if( !(status & GLUT_TEXTURE_WINDOW2D_STATUS_BIT_WINDOW_CREATED) ){
			#ifndef BE_QUIET
				std::cout << "window not created yet, cannot setup texture ptr in GLUTTextureWindow2D" << std::endl;
			#endif
			return 0;
		}

		texture.SetupTexturePtr(width, height, texture_ptr, internal_format, format, memory_type);

		return 1;
	}

	/**
		overload default draw function 
	*/
	static void DefaultDraw(){
		if( texture.tex_id ){
			texture.Bind();
			glColor3f(1, 1, 1);
			drawWholeTexture(0, 0, 1, 1, flip_flag);
			texture.UnBind();
		}
	}

	/**
		Reshape

		projection matrix will be updated
	*/
	static void DefaultReshapeFunc(int w, int h){
		GLUTTextureWindow2D<ID>::win_width = w;
		GLUTTextureWindow2D<ID>::win_height = h;

		//	Setup Projection Matrix
		glViewport(0, 0, GLUTTextureWindow2D<ID>::win_width, GLUTTextureWindow2D<ID>::win_height);
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		gluOrtho2D(GLUTTextureWindow2D<ID>::left, GLUTTextureWindow2D<ID>::right, GLUTTextureWindow2D<ID>::bottom, GLUTTextureWindow2D<ID>::top);

		//	set back to model view
		glMatrixMode(GL_MODELVIEW);
	}

	/**
		overload keyboard function
	*/
	static void DefaultKeyboardFunc(unsigned char key, int x, int y){
		switch( key ){
			case 'r':
				GLUTTextureWindow2D<ID>::left	= 0;
				GLUTTextureWindow2D<ID>::right	= 1;
				GLUTTextureWindow2D<ID>::bottom	= 0;
				GLUTTextureWindow2D<ID>::top		= 1;
				DefaultReshapeFunc(GLUTTextureWindow2D<ID>::win_width, GLUTTextureWindow2D<ID>::win_height);
				break;
			case 'f':
				flip_flag = !flip_flag;
				break;
			case 27:
				exit(0);
		}

		glutPostRedisplay();
	}

protected:
	int status;
	enum{
		GLUT_TEXTURE_WINDOW2D_STATUS_BIT_WINDOW_CREATED	= 0x01
	};
};

template<int ID> Texture	GLUTTextureWindow2D<ID>::texture;
template<int ID> int		GLUTTextureWindow2D<ID>::flip_flag;

//	======================================================
//	The following two types are used to create window in a
//	very easy way, but since the ID of all the windows are
//	zero, only one window can be created
//	======================================================

/**
	Manager of GLUTWindow

	Only one instance needed. It is responsible for setup idleFunc
	and enter glutMainLoop
*/
typedef GLUTWindowManager<0> DemoWindowManager;

/**
	GLUT window displaying 3D objects with ID = 0

	This typedef makes it convenient to setup 2D display
	environment, but make sure only one instance of GLUTWindow
	type should exist, or runtime error will accour!
*/
typedef GLUTWindow3D<0> DemoWindow3D;

/**
	GLUT window displaying 2D objects with ID = 0

	This typedef makes it convenient to setup 2D display
	environment, but make sure only one instance of GLUTWindow
	type should exist, or runtime error will accour!
*/
typedef GLUTWindow2D<0> DemoWindow2D;

/**
	GLUT window displaying texture with ID = 0

	This typedef makes it convenient to setup 2D display
	environment, but make sure only one instance of GLUTWindow
	type should exist, or runtime error will accour!
*/
typedef GLUTTextureWindow2D<0> DemoTextureWindow2D;

}}	//	end namespace yz::opengl


#endif	//	__YZ_GLUT_WINDOW_H__